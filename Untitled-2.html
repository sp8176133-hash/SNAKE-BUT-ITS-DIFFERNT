<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Snake (Arrow keys)</title>
    <style>
        html,body {height:100%; margin:0; display:flex; align-items:center; justify-content:center; background:#111;}
        canvas {background:#000; image-rendering:pixelated; border:4px solid #222;}
        .overlay {position:fixed; top:8px; left:8px; color:#0f0; font-family:monospace;}
    </style>
</head>
<body>
    <div class="overlay">Score: <span id="score">0</span></div>
    <canvas id="c" width="400" height="400"></canvas>

    <script>
    // Simple Snake game - controls: Arrow keys
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');

    const GRID = 20; // pixel size of one cell
    const COLS = canvas.width / GRID;
    const ROWS = canvas.height / GRID;
    const TICK_MS = 225; // speed

    

    let snake, dir, food, running, score, timer;

    function reset() {
        snake = [{x: Math.floor(COLS/2), y: Math.floor(ROWS/2)}];
        dir = {x: 1, y: 0};
        placeFood();
        score = 0;
        running = true;
        scoreEl.textContent = score;
        if (timer) clearInterval(timer);
        timer = setInterval(tick, TICK_MS);
    }

    function placeFood() {
        do {
            food = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
        } while (snake.some(s => s.x === food.x && s.y === food.y));
    }

    function tick() {
        if (!running) return;
        const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

        // wall collision
        if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) {
            gameOver();
            return;
        }
        // self collision
        if (snake.some(s => s.x === head.x && s.y === head.y)) {
            gameOver();
            return;
        }

        snake.unshift(head);

        // eat food
        if (head.x === food.x && head.y === food.y) {
            score += 1;
            scoreEl.textContent = score;
            placeFood();
        } else {
            snake.pop();
        }

        draw();
    }

    function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,canvas.width,canvas.height);

        // food
        ctx.fillStyle = '#e33';
        ctx.fillRect(food.x*GRID, food.y*GRID, GRID, GRID);

        // snake
        for (let i = snake.length-1; i >= 0; i--) {
            ctx.fillStyle = i === 0 ? '#7CFC00' : '#0f0';
            ctx.fillRect(snake[i].x*GRID + 1, snake[i].y*GRID + 1, GRID-2, GRID-2);
        }

        if (!running) {
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(0, canvas.height/2 - 30, canvas.width, 60);
            ctx.fillStyle = '#fff';
            ctx.font = '18px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Game Over - Press Enter to Restart', canvas.width/2, canvas.height/2 + 6);
        }
    }

    function gameOver() {
        running = false;
        clearInterval(timer);
        draw();
    }

    // Arrow key controls; prevent reversing into yourself
    window.addEventListener('keydown', e => {
        const key = e.key;
        if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(key)) {
            e.preventDefault(); // stop page scrolling
            let newDir;
            if (key === 'ArrowUp') newDir = {x:0, y:-1};
            if (key === 'ArrowDown') newDir = {x:0, y:1};
            if (key === 'ArrowLeft') newDir = {x:-1, y:0};
            if (key === 'ArrowRight') newDir = {x:1, y:0};
            // prevent 180-degree turn
            if (snake.length > 1 && newDir.x === -dir.x && newDir.y === -dir.y) return;
            dir = newDir;
        } else if (key === 'Enter') {
            if (!running) reset();
        }
    });

    // start
    reset();
    draw();
    </script>
</body>
</html>
